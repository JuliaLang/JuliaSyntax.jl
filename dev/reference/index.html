<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Syntax Trees · JuliaSyntax.jl</title><meta name="title" content="Syntax Trees · JuliaSyntax.jl"/><meta property="og:title" content="Syntax Trees · JuliaSyntax.jl"/><meta property="twitter:title" content="Syntax Trees · JuliaSyntax.jl"/><meta name="description" content="Documentation for JuliaSyntax.jl."/><meta property="og:description" content="Documentation for JuliaSyntax.jl."/><meta property="twitter:description" content="Documentation for JuliaSyntax.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuliaSyntax.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../howto/">How To</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Syntax Trees</a><ul class="internal"><li><a class="tocitem" href="#JuliaSyntax-trees-vs-Expr"><span>JuliaSyntax trees vs <code>Expr</code></span></a></li><li><a class="tocitem" href="#More-detail-on-tree-differences"><span>More detail on tree differences</span></a></li><li><a class="tocitem" href="#Tree-structure-reference"><span>Tree structure reference</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul></li><li><a class="tocitem" href="../design/">Design Discussion</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Syntax Trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Syntax Trees</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/JuliaSyntax.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/main/docs/src/reference.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Syntax-Trees"><a class="docs-heading-anchor" href="#Syntax-Trees">Syntax Trees</a><a id="Syntax-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax-Trees" title="Permalink"></a></h1><p>This section describes the syntax trees produced by JuliaSyntax, mainly in terms of their similarities and differences with the <code>Expr</code> tree data structures used since Julia 0.1.</p><h2 id="JuliaSyntax-trees-vs-Expr"><a class="docs-heading-anchor" href="#JuliaSyntax-trees-vs-Expr">JuliaSyntax trees vs <code>Expr</code></a><a id="JuliaSyntax-trees-vs-Expr-1"></a><a class="docs-heading-anchor-permalink" href="#JuliaSyntax-trees-vs-Expr" title="Permalink"></a></h2><p>The tree structure of <code>GreenNode</code>/<code>SyntaxNode</code> is similar to Julia&#39;s <code>Expr</code> data structure but there are various differences:</p><h3 id="Source-ordered-children"><a class="docs-heading-anchor" href="#Source-ordered-children">Source ordered children</a><a id="Source-ordered-children-1"></a><a class="docs-heading-anchor-permalink" href="#Source-ordered-children" title="Permalink"></a></h3><p>The children of our trees are strictly in source order. This has many consequences in places where <code>Expr</code> reorders child expressions.</p><ul><li>Infix and postfix operator calls have the operator name in the <em>second</em> child position. <code>a + b</code> is parsed as <code>(call-i a + b)</code> - where the infix <code>-i</code> flag indicates infix child position - rather than <code>Expr(:call, :+, :a, :b)</code>.</li><li>Generators are represented in source order as a single node rather than multiple nested flatten and generator expressions.</li></ul><h3 id="No-LineNumberNodes"><a class="docs-heading-anchor" href="#No-LineNumberNodes">No <code>LineNumberNode</code>s</a><a id="No-LineNumberNodes-1"></a><a class="docs-heading-anchor-permalink" href="#No-LineNumberNodes" title="Permalink"></a></h3><p>Our syntax nodes inherently stores source position, so there&#39;s no need for the <code>LineNumberNode</code>s used by <code>Expr</code>.</p><h3 id="More-consistent-/-less-redundant-blocks"><a class="docs-heading-anchor" href="#More-consistent-/-less-redundant-blocks">More consistent / less redundant <code>block</code>s</a><a id="More-consistent-/-less-redundant-blocks-1"></a><a class="docs-heading-anchor-permalink" href="#More-consistent-/-less-redundant-blocks" title="Permalink"></a></h3><p>Sometimes <code>Expr</code> needs redundant block constructs to store <code>LineNumberNode</code>s, but we don&#39;t need these. Also in cases which do use blocks we try to use them consistently.</p><ul><li>No block is used on the right hand side of short form function syntax</li><li>No block is used for the conditional in <code>elseif</code></li><li>No block is used for the body of anonymous functions after the <code>-&gt;</code></li><li><code>let</code> argument lists always use a block regardless of number or form of bindings</li></ul><h3 id="Faithful-representation-of-the-source-text-/-avoid-premature-lowering"><a class="docs-heading-anchor" href="#Faithful-representation-of-the-source-text-/-avoid-premature-lowering">Faithful representation of the source text / avoid premature lowering</a><a id="Faithful-representation-of-the-source-text-/-avoid-premature-lowering-1"></a><a class="docs-heading-anchor-permalink" href="#Faithful-representation-of-the-source-text-/-avoid-premature-lowering" title="Permalink"></a></h3><p>Some cases of &quot;premature lowering&quot; have been removed, preferring to represent the source text more closely.</p><ul><li><code>K&quot;macrocall&quot;</code> - allow users to easily distinguish macrocalls with parentheses from those without them (#218)</li><li>Grouping parentheses are represented with a node of kind <code>K&quot;parens&quot;</code> (#222)</li><li>The right hand side of <code>x where {T}</code> retains the <code>K&quot;braces&quot;</code> node around the <code>T</code> to distinguish it from <code>x where T</code>.</li><li>Ternary syntax is not immediately lowered to an <code>if</code> node: <code>a ? b : c</code> parses as <code>(? a b c)</code> rather than <code>Expr(:if, :a, :b, :c)</code> (#85)</li><li><code>global const</code> and <code>const global</code> are not normalized by the parser. This is done in <code>Expr</code> conversion (#130)</li><li><a href="#Do-blocks"><code>do</code> syntax</a> is nested as the last child of the call which the <code>do</code> lambda will be passed to (#98, #322)</li><li><code>@.</code> is not lowered to <code>@__dot__</code> inside the parser (#146)</li><li>Docstrings use the <code>K&quot;doc&quot;</code> kind, and are not lowered to <code>Core.@doc</code> until later (#217)</li><li>Juxtaposition uses the <code>K&quot;juxtapose&quot;</code> kind rather than lowering immediately to <code>*</code> (#220)</li><li><code>return</code> without a value has zero children, rather than lowering to <code>return nothing</code> (#220)</li><li>Command syntax <span>$`foo`$</span> parses into a <code>cmdstring</code> tree node wrapping the string, as <code>(cmdstring &quot;foo&quot;)</code> (#438). These are lowered to a macro call later rather than by the parser.</li></ul><h3 id="Containers-for-string-like-constructs"><a class="docs-heading-anchor" href="#Containers-for-string-like-constructs">Containers for string-like constructs</a><a id="Containers-for-string-like-constructs-1"></a><a class="docs-heading-anchor-permalink" href="#Containers-for-string-like-constructs" title="Permalink"></a></h3><p>String-like constructs always come within a container node, not as a single token. These are useful for tooling which works with the tokens of the source text. Also separating the delimiters from the text they delimit removes a whole class of tokenization errors and lets the parser deal with them.</p><ul><li>string always use <code>K&quot;string&quot;</code> to wrap strings, even when they only contain a single string chunk (#94)</li><li>char literals are wrapped in the <code>K&quot;char&quot;</code> kind, containing the character literal string along with their delimiters (#121)</li><li>backticks use the <code>K&quot;cmdstring&quot;</code> kind</li><li><code>var&quot;&quot;</code> syntax uses <code>K&quot;var&quot;</code> as the head (#127)</li><li>The parser splits triple quoted strings into string chunks interspersed with whitespace trivia</li></ul><h3 id="Improvements-for-AST-inconsistencies"><a class="docs-heading-anchor" href="#Improvements-for-AST-inconsistencies">Improvements for AST inconsistencies</a><a id="Improvements-for-AST-inconsistencies-1"></a><a class="docs-heading-anchor-permalink" href="#Improvements-for-AST-inconsistencies" title="Permalink"></a></h3><ul><li>Field access syntax like <code>a.b</code> is parsed as <code>(. a b)</code> rather than <code>(. a (quote b))</code> to avoid the inconsistency between this and actual quoted syntax literals like <code>:(b)</code> and <code>quote b end</code> (<a href="https://github.com/JuliaLang/JuliaSyntax.jl/issues/324">#342</a>)</li><li>Dotted call syntax like <code>f.(a,b)</code> and <code>a .+ b</code> has been made consistent with the <code>K&quot;dotcall&quot;</code> head (#90)</li><li>Standalone dotted operators are always parsed as <code>(. op)</code>. For example <code>.*(x,y)</code> is parsed as <code>(call (. *) x y)</code> (#240)</li><li>The <code>K&quot;=&quot;</code> kind is used for keyword syntax rather than <code>kw</code>, to avoid various inconsistencies and ambiguities (#103)</li><li>Unadorned postfix adjoint is parsed as <code>call</code> rather than as a syntactic operator for consistency with suffixed versions like <code>x&#39;ᵀ</code> (#124)</li></ul><h3 id="Improvements-to-awkward-AST-forms"><a class="docs-heading-anchor" href="#Improvements-to-awkward-AST-forms">Improvements to awkward AST forms</a><a id="Improvements-to-awkward-AST-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Improvements-to-awkward-AST-forms" title="Permalink"></a></h3><ul><li>Frakentuples with multiple parameter blocks like <code>(a=1, b=2; c=3; d=4)</code> are flattened into the parent tuple instead of using nested <code>K&quot;parameters&quot;</code> nodes (#133)</li><li>Using <code>try catch else finally end</code> is parsed with <code>K&quot;catch&quot;</code> <code>K&quot;else&quot;</code> and <code>K&quot;finally&quot;</code> children to avoid the awkwardness of the optional child nodes in the <code>Expr</code> representation (#234)</li><li>The dotted import path syntax as in <code>import A.b.c</code> is parsed with a <code>K&quot;importpath&quot;</code> kind rather than <code>K&quot;.&quot;</code>, because a bare <code>A.b.c</code> has a very different nested/quoted expression representation (#244)</li><li>We use flags rather than child nodes to represent the difference between <code>struct</code> and <code>mutable struct</code>, <code>module</code> and <code>baremodule</code> (#220)</li><li>Iterations are represented with the <code>iteration</code> and <code>in</code> heads rather than <code>=</code> within the header of a <code>for</code>. Thus <code>for i=is ; body end</code> parses to <code>(for (iteration (in i is)) (block body))</code>. Cartesian iteration as in <code>for a=as, b=bs body end</code> are represented with a nested <code>(iteration (in a as) (in b bs))</code> rather than a <code>block</code> containing <code>=</code> because these lists of iterators are neither semantically nor syntactically a sequence of statements, unlike other uses of <code>block</code>. Generators also use the <code>iteration</code> head - see information on that below.</li><li>Short form functions like <code>f(x) = x + 1</code> are represented with the <code>function</code> head rather than the <code>=</code> head. In this case the <code>SHORT_FORM_FUNCTION_FLAG</code> flag is set to allow the surface syntactic form to be easily distinguished from long form functions.</li></ul><h2 id="More-detail-on-tree-differences"><a class="docs-heading-anchor" href="#More-detail-on-tree-differences">More detail on tree differences</a><a id="More-detail-on-tree-differences-1"></a><a class="docs-heading-anchor-permalink" href="#More-detail-on-tree-differences" title="Permalink"></a></h2><h3 id="Generators"><a class="docs-heading-anchor" href="#Generators">Generators</a><a id="Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Generators" title="Permalink"></a></h3><p>Flattened generators are uniquely problematic because the Julia AST doesn&#39;t respect a key rule we normally expect: that the children of an AST node are a <em>contiguous</em> range in the source text. For example, the <code>for</code>s in <code>[xy for x in xs for y in ys]</code> are parsed in the normal order of a for loop to mean</p><pre><code class="nohighlight hljs">for x in xs
    for y in ys
        push!(xy, collection)
    end
end</code></pre><p>so the <code>xy</code> prefix is in the <em>body</em> of the innermost for loop. Following this, the standard Julia AST is like so:</p><pre><code class="nohighlight hljs">(flatten
  (generator
    (generator
      xy
      (= y ys))
    (= x xs)))</code></pre><p>however, note that if this tree were flattened, the order would be <code>(xy) (y in ys) (x in xs)</code> and the <code>x</code> and <code>y</code> iterations are <em>opposite</em> of the source order.</p><p>However, our green tree is strictly source-ordered, so we must deviate from the Julia AST. We deal with this by grouping cartesian products of iterators (separated by commas) within <code>iteration</code> blocks as in <code>for</code> loops, and use the length of the <code>iteration</code> block rather than the <code>flatten</code> head to distinguish flattened iterators. The nested flattens and generators of <code>Expr</code> forms are reconstructed later. In this form the tree structure resembles the source much more closely. For example, <code>(xy for x in xs for y in ys)</code> is parsed as</p><pre><code class="nohighlight hljs">(generator
  xy
  (iteration (in x xs))
  (iteration (in y ys)))</code></pre><p>And the cartesian iteration <code>(xy for x in xs, y in ys)</code> is parsed as</p><pre><code class="nohighlight hljs">(generator
  xy
  (iteration (in x xs) (in y ys)))</code></pre><h3 id="Whitespace-trivia-inside-strings"><a class="docs-heading-anchor" href="#Whitespace-trivia-inside-strings">Whitespace trivia inside strings</a><a id="Whitespace-trivia-inside-strings-1"></a><a class="docs-heading-anchor-permalink" href="#Whitespace-trivia-inside-strings" title="Permalink"></a></h3><p>For triple quoted strings, the indentation isn&#39;t part of the string data so should also be excluded from the string content within the green tree. That is, it should be treated as separate whitespace trivia tokens. With this separation things like formatting should be much easier. The same reasoning goes for escaping newlines and following whitespace with backslashes in normal strings.</p><p>Detecting string trivia during parsing means that string content is split over several tokens. Here we wrap these in the K&quot;string&quot; kind (as is already used for interpolations). The individual chunks can then be reassembled during Expr construction. (A possible alternative might be to reuse the K&quot;String&quot; and K&quot;CmdString&quot; kinds for groups of string chunks (without interpolation).)</p><p>Take as an example the following Julia fragment.</p><pre><code class="language-julia hljs">x = &quot;&quot;&quot;
    $a
    b&quot;&quot;&quot;</code></pre><p>Here this is parsed as <code>(= x (string-s a &quot;\n&quot; &quot;b&quot;))</code> (the <code>-s</code> flag in <code>string-s</code> means &quot;triple quoted string&quot;)</p><p>Looking at the green tree, we see the indentation before the <code>$a</code> and <code>b</code> are marked as trivia:</p><pre><code class="nohighlight hljs">julia&gt; text = &quot;x = \&quot;\&quot;\&quot;\n    \$a\n    b\&quot;\&quot;\&quot;&quot;
       show(stdout, MIME&quot;text/plain&quot;(), parseall(GreenNode, text, rule=:statement), text)
     1:23     │[=]
     1:1      │  Identifier             ✔   &quot;x&quot;
     2:2      │  Whitespace                 &quot; &quot;
     3:3      │  =                          &quot;=&quot;
     4:4      │  Whitespace                 &quot; &quot;
     5:23     │  [string]
     5:7      │    &quot;&quot;&quot;                      &quot;\&quot;\&quot;\&quot;&quot;
     8:8      │    String                   &quot;\n&quot;
     9:12     │    Whitespace               &quot;    &quot;
    13:13     │    $                        &quot;\$&quot;
    14:14     │    Identifier           ✔   &quot;a&quot;
    15:15     │    String               ✔   &quot;\n&quot;
    16:19     │    Whitespace               &quot;    &quot;
    20:20     │    String               ✔   &quot;b&quot;
    21:23     │    &quot;&quot;&quot;                      &quot;\&quot;\&quot;\&quot;&quot;</code></pre><h3 id="String-nodes-always-wrapped-in-K&quot;string&quot;-or-K&quot;cmdstring&quot;"><a class="docs-heading-anchor" href="#String-nodes-always-wrapped-in-K&quot;string&quot;-or-K&quot;cmdstring&quot;">String nodes always wrapped in <code>K&quot;string&quot;</code> or <code>K&quot;cmdstring&quot;</code></a><a id="String-nodes-always-wrapped-in-K&quot;string&quot;-or-K&quot;cmdstring&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#String-nodes-always-wrapped-in-K&quot;string&quot;-or-K&quot;cmdstring&quot;" title="Permalink"></a></h3><p>All strings are surrounded by a node of kind <code>K&quot;string&quot;</code>, even non-interpolated literals, so <code>&quot;x&quot;</code> parses as <code>(string &quot;x&quot;)</code>. This makes string handling simpler and more systematic because interpolations and triple strings with embedded trivia don&#39;t need to be treated differently. It also gives a container in which to attach the delimiting quotes.</p><p>The same goes for command strings which are always wrapped in <code>K&quot;cmdstring&quot;</code> regardless of whether they have multiple pieces (due to triple-quoted dedenting) or otherwise.</p><h3 id="Do-blocks"><a class="docs-heading-anchor" href="#Do-blocks">Do blocks</a><a id="Do-blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Do-blocks" title="Permalink"></a></h3><p><code>do</code> syntax is represented in the <code>Expr</code> AST with the <code>do</code> outside the call. This makes some sense syntactically (do appears as &quot;an operator&quot; after the function call).</p><p>However semantically this nesting is awkward because the lambda represented by the do block is passed to the call. This same problem occurs for the macro form <code>@f(x) do \n body end</code> where the macro expander needs a special rule to expand nestings of the form <code>Expr(:do, Expr(:macrocall ...), ...)</code>, rearranging the expression which are passed to this macro call rather than passing the expressions up the tree.</p><p>The implied closure is also lowered to a nested <code>Expr(:-&gt;)</code> expression, though it this somewhat premature to do this during parsing.</p><p>To resolve these problems we parse</p><pre><code class="nohighlight hljs">@f(x, y) do a, b\n body\n end
f(x, y) do a, b\n body\n end</code></pre><p>by tacking the <code>do</code> onto the end of the call argument list:</p><pre><code class="nohighlight hljs">(macrocall @f x y (do (tuple a b) body))
(call f x y (do (tuple a b) body))</code></pre><p>This achieves the following desirable properties</p><ol><li>Content of <code>do</code> is nested inside the call which improves the match between AST and semantics</li><li>Macro can be passed the syntax as-is rather than the macro expander rearranging syntax before passing it to the macro</li><li>In the future, a macro can detect when it&#39;s being passed do syntax rather than lambda syntax</li><li><code>do</code> head is used uniformly for both call and macrocall</li><li>We preserve the source ordering properties we need for the green tree.</li></ol><h2 id="Tree-structure-reference"><a class="docs-heading-anchor" href="#Tree-structure-reference">Tree structure reference</a><a id="Tree-structure-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-structure-reference" title="Permalink"></a></h2><p>This section may eventually contain a full description of the Julia AST. For now, we describe a few of the more subtle features.</p><h3 id="Concatenation-syntax"><a class="docs-heading-anchor" href="#Concatenation-syntax">Concatenation syntax</a><a id="Concatenation-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenation-syntax" title="Permalink"></a></h3><p>Concatenation syntax comes in two syntax forms:</p><ul><li>The traditional <code>hcat</code>/<code>vcat</code>/<code>row</code> which deal with concatenation or matrix construction along dimensions one and two.</li><li>The new <code>ncat</code>/<code>nrow</code> syntax which deals with concatenation or array construction along arbitrary dimensions.</li></ul><p>We write <code>ncat-3</code> for concatenation along the third dimension. (The <code>3</code> is stored in the head flags for <code>SyntaxNode</code> trees, and in the first <code>arg</code> for <code>Expr</code> trees.) Semantically the new syntax can work like the old:</p><ul><li><code>ncat-1</code> is the same as <code>vcat</code></li><li><code>ncat-2</code> is the same as <code>hcat</code></li><li><code>row</code> is the same as <code>nrow-2</code></li></ul><h4 id="Vertical-concatenation-(dimension-1)"><a class="docs-heading-anchor" href="#Vertical-concatenation-(dimension-1)">Vertical concatenation (dimension 1)</a><a id="Vertical-concatenation-(dimension-1)-1"></a><a class="docs-heading-anchor-permalink" href="#Vertical-concatenation-(dimension-1)" title="Permalink"></a></h4><p>Vertical concatenation along dimension 1 can be done with semicolons or newlines</p><pre><code class="language-julia-repl hljs">julia&gt; print_tree(:([a
                     b]))
Expr(:vcat)
├─ :a
└─ :b

julia&gt; print_tree(:([a ; b]))
Expr(:vcat)
├─ :a
└─ :b</code></pre><h4 id="Horizontal-concatenation-(dimension-2)"><a class="docs-heading-anchor" href="#Horizontal-concatenation-(dimension-2)">Horizontal concatenation (dimension 2)</a><a id="Horizontal-concatenation-(dimension-2)-1"></a><a class="docs-heading-anchor-permalink" href="#Horizontal-concatenation-(dimension-2)" title="Permalink"></a></h4><p>For horizontal concatenation along dimension 2, use spaces or double semicolons</p><pre><code class="language-julia-repl hljs">julia&gt; print_tree(:([a b]))
Expr(:hcat)
├─ :a
└─ :b

julia&gt; print_tree(:([a ;; b]))
Expr(:ncat)
├─ 2
├─ :a
└─ :b</code></pre><h4 id="Mixed-concatenation"><a class="docs-heading-anchor" href="#Mixed-concatenation">Mixed concatenation</a><a id="Mixed-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-concatenation" title="Permalink"></a></h4><p>Concatenation along dimensions 1 and 2 can be done with spaces and single semicolons or newlines, producing a mixture of <code>vcat</code> and <code>row</code> expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; print_tree(:([a b
                     c d]))
# OR
julia&gt; print_tree(:([a b ; c d]))
Expr(:vcat)
├─ Expr(:row)
│  ├─ :a
│  └─ :b
└─ Expr(:row)
   ├─ :c
   └─ :d</code></pre><p>General n-dimensional concatenation results in nested <code>ncat</code> and <code>nrow</code>, for example</p><pre><code class="language-julia-repl hljs">julia&gt; print_tree(:([a ; b ;; c ; d ;;; x]))
Expr(:ncat)
├─ 3
├─ Expr(:nrow)
│  ├─ 2
│  ├─ Expr(:nrow)
│  │  ├─ 1
│  │  ├─ :a
│  │  └─ :b
│  └─ Expr(:nrow)
│     ├─ 1
│     ├─ :c
│     └─ :d
└─ :x</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../howto/">« How To</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 18 August 2024 10:50">Sunday 18 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
