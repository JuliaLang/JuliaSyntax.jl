<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuliaSyntax.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuliaSyntax.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../howto/">How To</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/">Syntax Trees</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Tokenization"><span>Tokenization</span></a></li><li><a class="tocitem" href="#Source-file-handling"><span>Source file handling</span></a></li><li><a class="tocitem" href="#Expression-heads/kinds"><span>Expression heads/kinds</span></a></li><li><a class="tocitem" href="#Syntax-tree-types"><span>Syntax tree types</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../design/">Design Discussion</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/main/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.parsestmt" href="#JuliaSyntax.parsestmt"><code>JuliaSyntax.parsestmt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"># Parse a single expression/statement
parsestmt(TreeType, text, [index];
          version=VERSION,
          ignore_trivia=true,
          filename=nothing,
          ignore_errors=false,
          ignore_warnings=ignore_errors)

# Parse all statements at top level (file scope)
parseall(...)

# Parse a single syntax atom
parseatom(...)</code></pre><p>Parse Julia source code string <code>text</code> into a data structure of type <code>TreeType</code>. <code>parsestmt</code> parses a single Julia statement, <code>parseall</code> parses top level statements at file scope and <code>parseatom</code> parses a single Julia identifier or other &quot;syntax atom&quot;.</p><p>If <code>text</code> is passed without <code>index</code>, all the input text must be consumed and a tree data structure is returned. When an integer byte <code>index</code> is passed, a tuple <code>(tree, next_index)</code> will be returned containing the next index in <code>text</code> to resume parsing. By default whitespace and comments before and after valid code are ignored but you can turn this off by setting <code>ignore_trivia=false</code>.</p><p><code>version</code> (default <code>VERSION</code>) may be used to set the syntax version to any Julia version <code>&gt;= v&quot;1.0&quot;</code>. We aim to parse all Julia syntax which has been added after v&quot;1.0&quot;, emitting an error if it&#39;s not compatible with the requested <code>version</code>.</p><p>Pass <code>filename</code> to set any file name information embedded within the output tree, if applicable. This will also annotate errors and warnings with the source file name.</p><p>A <code>ParseError</code> will be thrown if any errors or warnings occurred during parsing. To avoid exceptions due to warnings, use <code>ignore_warnings=true</code>. To also avoid exceptions due to errors, use <code>ignore_errors=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL139-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.parseall" href="#JuliaSyntax.parseall"><code>JuliaSyntax.parseall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"># Parse a single expression/statement
parsestmt(TreeType, text, [index];
          version=VERSION,
          ignore_trivia=true,
          filename=nothing,
          ignore_errors=false,
          ignore_warnings=ignore_errors)

# Parse all statements at top level (file scope)
parseall(...)

# Parse a single syntax atom
parseatom(...)</code></pre><p>Parse Julia source code string <code>text</code> into a data structure of type <code>TreeType</code>. <code>parsestmt</code> parses a single Julia statement, <code>parseall</code> parses top level statements at file scope and <code>parseatom</code> parses a single Julia identifier or other &quot;syntax atom&quot;.</p><p>If <code>text</code> is passed without <code>index</code>, all the input text must be consumed and a tree data structure is returned. When an integer byte <code>index</code> is passed, a tuple <code>(tree, next_index)</code> will be returned containing the next index in <code>text</code> to resume parsing. By default whitespace and comments before and after valid code are ignored but you can turn this off by setting <code>ignore_trivia=false</code>.</p><p><code>version</code> (default <code>VERSION</code>) may be used to set the syntax version to any Julia version <code>&gt;= v&quot;1.0&quot;</code>. We aim to parse all Julia syntax which has been added after v&quot;1.0&quot;, emitting an error if it&#39;s not compatible with the requested <code>version</code>.</p><p>Pass <code>filename</code> to set any file name information embedded within the output tree, if applicable. This will also annotate errors and warnings with the source file name.</p><p>A <code>ParseError</code> will be thrown if any errors or warnings occurred during parsing. To avoid exceptions due to warnings, use <code>ignore_warnings=true</code>. To also avoid exceptions due to errors, use <code>ignore_errors=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL142-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.parseatom" href="#JuliaSyntax.parseatom"><code>JuliaSyntax.parseatom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"># Parse a single expression/statement
parsestmt(TreeType, text, [index];
          version=VERSION,
          ignore_trivia=true,
          filename=nothing,
          ignore_errors=false,
          ignore_warnings=ignore_errors)

# Parse all statements at top level (file scope)
parseall(...)

# Parse a single syntax atom
parseatom(...)</code></pre><p>Parse Julia source code string <code>text</code> into a data structure of type <code>TreeType</code>. <code>parsestmt</code> parses a single Julia statement, <code>parseall</code> parses top level statements at file scope and <code>parseatom</code> parses a single Julia identifier or other &quot;syntax atom&quot;.</p><p>If <code>text</code> is passed without <code>index</code>, all the input text must be consumed and a tree data structure is returned. When an integer byte <code>index</code> is passed, a tuple <code>(tree, next_index)</code> will be returned containing the next index in <code>text</code> to resume parsing. By default whitespace and comments before and after valid code are ignored but you can turn this off by setting <code>ignore_trivia=false</code>.</p><p><code>version</code> (default <code>VERSION</code>) may be used to set the syntax version to any Julia version <code>&gt;= v&quot;1.0&quot;</code>. We aim to parse all Julia syntax which has been added after v&quot;1.0&quot;, emitting an error if it&#39;s not compatible with the requested <code>version</code>.</p><p>Pass <code>filename</code> to set any file name information embedded within the output tree, if applicable. This will also annotate errors and warnings with the source file name.</p><p>A <code>ParseError</code> will be thrown if any errors or warnings occurred during parsing. To avoid exceptions due to warnings, use <code>ignore_warnings=true</code>. To also avoid exceptions due to errors, use <code>ignore_errors=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL145-L183">source</a></section></article><h3 id="Low-level-parsing-API"><a class="docs-heading-anchor" href="#Low-level-parsing-API">Low level parsing API</a><a id="Low-level-parsing-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-parsing-API" title="Permalink"></a></h3><p>The <code>ParseStream</code> interface which provides a low-level stream-like I/O interface for writing the parser. The parser does not depend on or produce any concrete tree data structure as part of the parsing phase but the output spans can be post-processed into various tree data structures as required using <a href="#JuliaSyntax.build_tree"><code>JuliaSyntax.build_tree</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.parse!" href="#JuliaSyntax.parse!"><code>JuliaSyntax.parse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse!(stream::ParseStream; rule=:all)</code></pre><p>Parse Julia source code from a <a href="#JuliaSyntax.ParseStream"><code>ParseStream</code></a> object. Output tree data structures may be extracted from <code>stream</code> with the <a href="#JuliaSyntax.build_tree"><code>build_tree</code></a> function.</p><p><code>rule</code> may be any of</p><ul><li><code>:all</code> (default) — parse a whole &quot;file&quot; of top level statements. In this mode, the parser expects to fully consume the input.</li><li><code>:statement</code> — parse a single statement, or statements separated by semicolons.</li><li><code>:atom</code> — parse a single syntax &quot;atom&quot;: a literal, identifier, or parenthesized expression.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL23-L35">source</a></section><section><div><pre><code class="nohighlight hljs">parse!(TreeType, io::IO; rule=:all, version=VERSION)</code></pre><p>Parse Julia source code from a seekable <code>IO</code> object. The output is a tuple <code>(tree, diagnostics)</code>. When <code>parse!</code> returns, the stream <code>io</code> is positioned directly after the last byte which was consumed during parsing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.ParseStream" href="#JuliaSyntax.ParseStream"><code>JuliaSyntax.ParseStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParseStream(text::AbstractString,          index::Integer=1; version=VERSION)
ParseStream(text::IO;                                        version=VERSION)
ParseStream(text::Vector{UInt8},           index::Integer=1; version=VERSION)
ParseStream(ptr::Ptr{UInt8}, len::Integer, index::Integer=1; version=VERSION)</code></pre><p>Construct a <code>ParseStream</code> from input which may come in various forms:</p><ul><li>An string (zero copy for <code>String</code> and <code>SubString</code>)</li><li>An <code>IO</code> object (zero copy for <code>IOBuffer</code>). The <code>IO</code> object must be seekable.</li><li>A buffer of bytes (zero copy). The caller is responsible for preserving buffers passed as <code>(ptr,len)</code>.</li></ul><p>A byte <code>index</code> may be provided as the position to start parsing.</p><p>ParseStream provides an IO interface for the parser which provides lexing of the source text input into tokens, manages insignificant whitespace tokens on behalf of the parser, and stores output tokens and tree nodes in a pair of output arrays.</p><p><code>version</code> (default <code>VERSION</code>) may be used to set the syntax version to any Julia version <code>&gt;= v&quot;1.0&quot;</code>. We aim to parse all Julia syntax which has been added after v&quot;1.0&quot;, emitting an error if it&#39;s not compatible with the requested <code>version</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parse_stream.jl#LL210-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.build_tree" href="#JuliaSyntax.build_tree"><code>JuliaSyntax.build_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_tree(make_node::Function, ::Type{StackEntry}, stream::ParseStream;
           wrap_toplevel_as_kind=nothing, kws...)</code></pre><p>Construct a tree from a ParseStream using depth-first traversal. <code>make_node</code> must have the signature</p><pre><code class="nohighlight hljs">make_node(head::SyntaxHead, span::Integer, children)</code></pre><p>where <code>children</code> is either <code>nothing</code> for leaf nodes or an iterable of the children of type <code>StackEntry</code> for internal nodes. <code>StackEntry</code> may be a node type, but also may include other information required during building the tree.</p><p>A single node which covers the input is expected, but if the ParseStream has multiple nodes at the top level, <code>wrap_toplevel_as_kind</code> may be used to wrap them in a single node.</p><p>The tree here is constructed depth-first in postorder.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parse_stream.jl#LL992-L1010">source</a></section></article><h2 id="Tokenization"><a class="docs-heading-anchor" href="#Tokenization">Tokenization</a><a id="Tokenization-1"></a><a class="docs-heading-anchor-permalink" href="#Tokenization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.tokenize" href="#JuliaSyntax.tokenize"><code>JuliaSyntax.tokenize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tokenize(text)</code></pre><p>Returns the tokenized UTF-8 encoded <code>text</code> as a vector of <code>Token</code>s. The text for the token can be retreived by using <code>untokenize()</code>. The full text can be reconstructed with, for example, <code>join(untokenize.(tokenize(text), text))</code>.</p><p>This interface works on UTF-8 encoded string or buffer data only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL171-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.untokenize" href="#JuliaSyntax.untokenize"><code>JuliaSyntax.untokenize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the string representation of a token kind, or <code>nothing</code> if the kind represents a class of tokens like K&quot;Identifier&quot;.</p><p>When <code>unique=true</code> only return a string when the kind uniquely defines the corresponding input token, otherwise return <code>nothing</code>.  When <code>unique=false</code>, return the name of the kind.</p><p>TODO: Replace <code>untokenize()</code> with <code>Base.string()</code>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/kinds.jl#LL1072-L1081">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.Token" href="#JuliaSyntax.Token"><code>JuliaSyntax.Token</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Token type resulting from calling <code>tokenize(text)</code></p><p>Use</p><ul><li><code>kind(tok)</code> to get the token kind</li><li><code>untokenize(tok, text)</code> to retreive the text</li><li>Predicates like <code>is_error(tok)</code> to query token categories and flags</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parser_api.jl#LL154-L161">source</a></section></article><h2 id="Source-file-handling"><a class="docs-heading-anchor" href="#Source-file-handling">Source file handling</a><a id="Source-file-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Source-file-handling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.SourceFile" href="#JuliaSyntax.SourceFile"><code>JuliaSyntax.SourceFile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SourceFile(code [; filename=nothing, first_line=1])</code></pre><p>A UTF-8 source code string with associated file name and line number.</p><p><code>SourceFile</code> stores the character positions of line starts to facilitate indexing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/source_files.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.highlight" href="#JuliaSyntax.highlight"><code>JuliaSyntax.highlight</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Print the lines of source code surrounding the given byte <code>range</code>, which is highlighted with background <code>color</code> and markers in the text.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/source_files.jl#LL178-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.sourcetext" href="#JuliaSyntax.sourcetext"><code>JuliaSyntax.sourcetext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sourcetext(source::SourceFile)</code></pre><p>Get the full source text of a <code>SourceFile</code> as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/source_files.jl#LL122-L126">source</a></section><section><div><pre><code class="nohighlight hljs">sourcetext(stream::ParseStream; steal_textbuf=true)</code></pre><p>Return the source text being parsed by this <code>ParseStream</code> as a UTF-8 encoded string.</p><p>If <code>steal_textbuf==true</code>, this is permitted to steal the content of the stream&#39;s text buffer. Note that this leaves the <code>ParseStream</code> in an invalid state for further parsing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parse_stream.jl#LL1083-L1092">source</a></section><section><div><pre><code class="nohighlight hljs">sourcetext(node)</code></pre><p>Get the full source text of a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/syntax_tree.jl#LL112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.source_line" href="#JuliaSyntax.source_line"><code>JuliaSyntax.source_line</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get the line number at the given byte index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/source_files.jl#LL44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.source_location" href="#JuliaSyntax.source_location"><code>JuliaSyntax.source_location</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get line number and character within the line at the given byte index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/source_files.jl#LL49-L51">source</a></section></article><h2 id="Expression-heads/kinds"><a class="docs-heading-anchor" href="#Expression-heads/kinds">Expression heads/kinds</a><a id="Expression-heads/kinds-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-heads/kinds" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.Kind" href="#JuliaSyntax.Kind"><code>JuliaSyntax.Kind</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">K&quot;name&quot;
Kind(namestr)</code></pre><p><code>Kind</code> is a type tag for specifying the type of tokens and interior nodes of a syntax tree. Abstractly, this tag is used to define our own <em>sum types</em> for syntax tree nodes. We do this explicitly outside the Julia type system because (a) Julia doesn&#39;t have sum types and (b) we want concrete data structures which are unityped from the Julia compiler&#39;s point of view, for efficiency.</p><p>Naming rules:</p><ul><li>Kinds which correspond to exactly one textural form are represented with that text. This includes keywords like K&quot;for&quot; and operators like K&quot;*&quot;.</li><li>Kinds which represent many textural forms have UpperCamelCase names. This includes kinds like K&quot;Identifier&quot; and K&quot;Comment&quot;.</li><li>Kinds which exist merely as delimiters are all uppercase</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/kinds.jl#LL921-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.SyntaxHead" href="#JuliaSyntax.SyntaxHead"><code>JuliaSyntax.SyntaxHead</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SyntaxHead(kind, flags)</code></pre><p>A <code>SyntaxHead</code> combines the <a href="#JuliaSyntax.Kind"><code>Kind</code></a> of a syntactic construct with a set of flags. The kind defines the broad &quot;type&quot; of the syntactic construct, while the flag bits compactly store more detailed information about the construct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parse_stream.jl#LL72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.@K_str" href="#JuliaSyntax.@K_str"><code>JuliaSyntax.@K_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">K&quot;s&quot;</code></pre><p>The kind of a token or AST internal node with string &quot;s&quot;.</p><p>For example</p><ul><li>K&quot;)&quot; is the kind of the right parenthesis token</li><li>K&quot;block&quot; is the kind of a block of code (eg, statements within a begin-end).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/kinds.jl#LL1002-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.kind" href="#JuliaSyntax.kind"><code>JuliaSyntax.kind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kind(x)</code></pre><p>Return the <code>Kind</code> of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/kinds.jl#LL1028-L1032">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.head" href="#JuliaSyntax.head"><code>JuliaSyntax.head</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">head(x)</code></pre><p>Get the <a href="#JuliaSyntax.SyntaxHead"><code>SyntaxHead</code></a> of a node of a tree or other syntax-related data structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/syntax_tree.jl#LL99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.flags" href="#JuliaSyntax.flags"><code>JuliaSyntax.flags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flags(x)</code></pre><p>Return the flag bits of a syntactic construct. Prefer to query these with the predicates <code>is_trivia</code>, <code>is_prefix_call</code>, <code>is_infix_op_call</code>, <code>is_prefix_op_call</code>, <code>is_postfix_op_call</code>, <code>is_dotted</code>, <code>is_suffixed</code>, <code>is_decorated</code>.</p><p>Or extract numeric portion of the flags with <code>numeric_flags</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/parse_stream.jl#LL86-L95">source</a></section></article><p>see also predicates related to <code>flags</code>.</p><h2 id="Syntax-tree-types"><a class="docs-heading-anchor" href="#Syntax-tree-types">Syntax tree types</a><a id="Syntax-tree-types-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax-tree-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.SyntaxNode" href="#JuliaSyntax.SyntaxNode"><code>JuliaSyntax.SyntaxNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SyntaxNode(source::SourceFile, raw::GreenNode{SyntaxHead};
           keep_parens=false, position::Integer=1)</code></pre><p>An AST node with a similar layout to <code>Expr</code>. Typically constructed from source text by calling one of the parser API functions such as <a href="#JuliaSyntax.parseall"><code>parseall</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/syntax_tree.jl#LL47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaSyntax.GreenNode" href="#JuliaSyntax.GreenNode"><code>JuliaSyntax.GreenNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreenNode(head, span)
GreenNode(head, children...)</code></pre><p>A &quot;green tree&quot; is a lossless syntax tree which overlays all the source text. The most basic properties of a green tree are that:</p><ul><li>Nodes cover a contiguous span of bytes in the text</li><li>Sibling nodes are ordered in the same order as the text</li></ul><p>As implementation choices, we choose that:</p><ul><li>Nodes are immutable and don&#39;t know their parents or absolute position, so can be cached and reused</li><li>Nodes are homogenously typed at the language level so they can be stored concretely, with the <code>head</code> defining the node type. Normally this would include a &quot;syntax kind&quot; enumeration, but it can also include flags and record information the parser knew about the layout of the child nodes.</li><li>For simplicity and uniformity, leaf nodes cover a single token in the source. This is like rust-analyzer, but different from Roslyn where leaves can include syntax trivia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/JuliaSyntax.jl/blob/ca83d08033d329e68ee40cebbff5b4f5ec3f5fc8/src/green_tree.jl#LL1-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« Syntax Trees</a><a class="docs-footer-nextpage" href="../design/">Design Discussion »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 9 June 2023 22:37">Friday 9 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
